'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

const graphql = require('graphql');

const DateTime = new graphql.GraphQLScalarType({
    name: 'DateTime',
    description: 'Use JavaScript Date object for date/time fields.',
    serialize(value) {
        let v = value;
        if (!(v instanceof Date) && typeof v !== 'string' && typeof v !== 'number') {
            throw new TypeError(`Value is not an instance of Date, Date string or number: ${JSON.stringify(v)}`);
        }
        if (typeof v === 'string') {
            v = new Date();
            v.setTime(Date.parse(value));
        }
        else if (typeof v === 'number') {
            v = new Date(v);
        }
        // eslint-disable-next-line no-restricted-globals
        if (Number.isNaN(v.getTime())) {
            throw new TypeError(`Value is not a valid Date: ${JSON.stringify(v)}`);
        }
        return v.toJSON();
    },
    parseValue(value) {
        const date = new Date(value);
        // eslint-disable-next-line no-restricted-globals
        if (Number.isNaN(date.getTime())) {
            throw new TypeError(`Value is not a valid Date: ${value}`);
        }
        return date;
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING && ast.kind !== graphql.Kind.INT) {
            throw new graphql.GraphQLError(`Can only parse strings & integers to dates but got a: ${ast.kind}`);
        }
        const result = new Date(ast.kind === graphql.Kind.INT ? Number(ast.value) : ast.value);
        // eslint-disable-next-line no-restricted-globals
        if (Number.isNaN(result.getTime())) {
            throw new graphql.GraphQLError(`Value is not a valid Date: ${ast.value}`);
        }
        return result;
    },
});

const validate = (value) => {
    const UTC_OFFSET_REGEX = /^([+-]?)(\d{2}):(\d{2})$/;
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    if (!UTC_OFFSET_REGEX.test(value)) {
        throw new TypeError(`Value is not a valid UTC Offset: ${value}`);
    }
    return value;
};
const UtcOffset = new graphql.GraphQLScalarType({
    name: 'UtcOffset',
    description: 'A field whose value is a UTC Offset: https://en.wikipedia.org/wiki/List_of_tz_database_time_zones',
    serialize: validate,
    parseValue: validate,
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as UTC Offset but got a: ${ast.kind}`);
        }
        return validate(ast.value);
    },
});

var VALUE_RANGES;
(function (VALUE_RANGES) {
    VALUE_RANGES[VALUE_RANGES["NEGATIVE"] = 0] = "NEGATIVE";
    VALUE_RANGES[VALUE_RANGES["NON_NEGATIVE"] = 1] = "NON_NEGATIVE";
    VALUE_RANGES[VALUE_RANGES["POSITIVE"] = 2] = "POSITIVE";
    VALUE_RANGES[VALUE_RANGES["NON_POSITIVE"] = 3] = "NON_POSITIVE";
})(VALUE_RANGES || (VALUE_RANGES = {}));
var VALUE_TYPES;
(function (VALUE_TYPES) {
    VALUE_TYPES[VALUE_TYPES["INT"] = 0] = "INT";
    VALUE_TYPES[VALUE_TYPES["FLOAT"] = 1] = "FLOAT";
})(VALUE_TYPES || (VALUE_TYPES = {}));
const VALIDATIONS = {
    NonPositiveInt: {
        range: VALUE_RANGES.NON_POSITIVE,
        type: VALUE_TYPES.INT,
    },
    PositiveInt: {
        range: VALUE_RANGES.POSITIVE,
        type: VALUE_TYPES.INT,
    },
    NonNegativeInt: {
        range: VALUE_RANGES.NON_NEGATIVE,
        type: VALUE_TYPES.INT,
    },
    NegativeInt: {
        range: VALUE_RANGES.NEGATIVE,
        type: VALUE_TYPES.INT,
    },
    NonPositiveFloat: {
        range: VALUE_RANGES.NON_POSITIVE,
        type: VALUE_TYPES.FLOAT,
    },
    PositiveFloat: {
        range: VALUE_RANGES.POSITIVE,
        type: VALUE_TYPES.FLOAT,
    },
    NonNegativeFloat: {
        range: VALUE_RANGES.NON_NEGATIVE,
        type: VALUE_TYPES.FLOAT,
    },
    NegativeFloat: {
        range: VALUE_RANGES.NEGATIVE,
        type: VALUE_TYPES.FLOAT,
    },
};
// TODO: Consider implementing coercion like this...
// See: https://github.com/graphql/graphql-js/blob/master/src/type/scalars.js#L13
// See: https://github.com/graphql/graphql-js/blob/master/src/type/scalars.js#L60
function _validateInt(value) {
    if (!Number.isFinite(value)) {
        throw new TypeError(`Value is not a finite number: ${value}`);
    }
    if (!Number.isInteger(value)) {
        throw new TypeError(`Value is not an integer: ${value}`);
    }
    if (!Number.isSafeInteger(value)) {
        throw new TypeError(`Value is not a safe integer: ${value}`);
    }
}
function _validateFloat(value) {
    if (!Number.isFinite(value)) {
        throw new TypeError(`Value is not a finite number: ${value}`);
    }
}
function processValue(value, validation) {
    const { range, type } = validation;
    /* eslint-disable no-restricted-globals */
    if (value === null ||
        typeof value === 'undefined' ||
        isNaN(value) ||
        Number.isNaN(value) ||
        value === Number.NaN) {
        throw new TypeError(`Value is not a number: ${value}`);
    }
    /* eslint-enable */
    let parsedValue;
    switch (type) {
        case VALUE_TYPES.FLOAT:
            parsedValue = parseFloat(value);
            _validateFloat(parsedValue);
            break;
        case VALUE_TYPES.INT:
            parsedValue = parseInt(value, 10);
            _validateInt(parsedValue);
            break;
        // no -op, return undefined
    }
    if ((range === VALUE_RANGES.NEGATIVE && !(parsedValue < 0)) ||
        (range === VALUE_RANGES.NON_NEGATIVE && !(parsedValue >= 0)) ||
        (range === VALUE_RANGES.POSITIVE && !(parsedValue > 0)) ||
        (range === VALUE_RANGES.NON_POSITIVE && !(parsedValue <= 0))) {
        throw new TypeError(`Value is not a ${VALUE_RANGES[range]
            .toLowerCase()
            .replace('_', '-')} number: ${value}`);
    }
    return parsedValue;
}

const NonPositiveInt = new graphql.GraphQLScalarType({
    name: 'NonPositiveInt',
    description: 'Integers that will have a value of 0 or less.',
    serialize(value) {
        return processValue(value, VALIDATIONS.NonPositiveInt);
    },
    parseValue(value) {
        return processValue(value, VALIDATIONS.NonPositiveInt);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.INT) {
            throw new graphql.GraphQLError(`Can only validate integers as non-positive integers but got a: ${ast.kind}`);
        }
        return processValue(ast.value, VALIDATIONS.NonPositiveInt);
    },
});

const PositiveInt = new graphql.GraphQLScalarType({
    name: 'PositiveInt',
    description: 'Integers that will have a value greater than 0.',
    serialize(value) {
        return processValue(value, VALIDATIONS.PositiveInt);
    },
    parseValue(value) {
        return processValue(value, VALIDATIONS.PositiveInt);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.INT) {
            throw new graphql.GraphQLError(`Can only validate integers as positive integers but got a: ${ast.kind}`);
        }
        return processValue(ast.value, VALIDATIONS.PositiveInt);
    },
});

function NonNegativeIntFactory (name = 'NonNegativeInt') {
    return new graphql.GraphQLScalarType({
        name,
        description: 'Integers that will have a value of 0 or more.',
        serialize(value) {
            return processValue(value, VALIDATIONS.NonNegativeInt);
        },
        parseValue(value) {
            return processValue(value, VALIDATIONS.NonNegativeInt);
        },
        parseLiteral(ast) {
            if (ast.kind !== graphql.Kind.INT) {
                throw new graphql.GraphQLError(`Can only validate integers as non-negative integers but got a: ${ast.kind}`);
            }
            return processValue(ast.value, VALIDATIONS.NonNegativeInt);
        },
    });
}

const NegativeInt = new graphql.GraphQLScalarType({
    name: 'NegativeInt',
    description: 'Integers that will have a value less than 0.',
    serialize(value) {
        return processValue(value, VALIDATIONS.NegativeInt);
    },
    parseValue(value) {
        return processValue(value, VALIDATIONS.NegativeInt);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.INT) {
            throw new graphql.GraphQLError(`Can only validate integers as negative integers but got a: ${ast.kind}`);
        }
        return processValue(ast.value, VALIDATIONS.NegativeInt);
    },
});

const NonPositiveFloat = new graphql.GraphQLScalarType({
    name: 'NonPositiveFloat',
    description: 'Floats that will have a value of 0 or less.',
    serialize(value) {
        return processValue(value, VALIDATIONS.NonPositiveFloat);
    },
    parseValue(value) {
        return processValue(value, VALIDATIONS.NonPositiveFloat);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.FLOAT && ast.kind !== graphql.Kind.INT) {
            throw new graphql.GraphQLError(`Can only validate floating point numbers as non-positive floating point numbers but got a: ${ast.kind}`);
        }
        return processValue(ast.value, VALIDATIONS.NonPositiveFloat);
    },
});

const PositiveFloat = new graphql.GraphQLScalarType({
    name: 'PositiveFloat',
    description: 'Floats that will have a value greater than 0.',
    serialize(value) {
        return processValue(value, VALIDATIONS.PositiveFloat);
    },
    parseValue(value) {
        return processValue(value, VALIDATIONS.PositiveFloat);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.FLOAT && ast.kind !== graphql.Kind.INT) {
            throw new graphql.GraphQLError(`Can only validate floating point numbers as positive floating point numbers but got a: ${ast.kind}`);
        }
        return processValue(ast.value, VALIDATIONS.PositiveFloat);
    },
});

function NonNegativeFloatFactory (name = 'NonNegativeFloat') {
    return new graphql.GraphQLScalarType({
        name,
        description: 'Floats that will have a value of 0 or more.',
        serialize(value) {
            return processValue(value, VALIDATIONS.NonNegativeFloat);
        },
        parseValue(value) {
            return processValue(value, VALIDATIONS.NonNegativeFloat);
        },
        parseLiteral(ast) {
            if (ast.kind !== graphql.Kind.FLOAT && ast.kind !== graphql.Kind.INT) {
                throw new graphql.GraphQLError(`Can only validate floating point numbers as non-negative floating point numbers but got a: ${ast.kind}`);
            }
            return processValue(ast.value, VALIDATIONS.NonNegativeFloat);
        },
    });
}

const NegativeFloat = new graphql.GraphQLScalarType({
    name: 'NegativeFloat',
    description: 'Floats that will have a value less than 0.',
    serialize(value) {
        return processValue(value, VALIDATIONS.NegativeFloat);
    },
    parseValue(value) {
        return processValue(value, VALIDATIONS.NegativeFloat);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.FLOAT && ast.kind !== graphql.Kind.INT) {
            throw new graphql.GraphQLError(`Can only validate floating point numbers as negative floating point numbers but got a: ${ast.kind}`);
        }
        return processValue(ast.value, VALIDATIONS.NegativeFloat);
    },
});

const validate$1 = (value) => {
    const EMAIL_ADDRESS_REGEX = /^[a-zA-Z0-9.!#$%&’*+/=?^_`{|}~-]+@[a-zA-Z0-9-]+(?:\.[a-zA-Z0-9-]+)*$/;
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    if (!EMAIL_ADDRESS_REGEX.test(value)) {
        throw new TypeError(`Value is not a valid email address: ${value}`);
    }
    return value;
};
const EmailAddress = new graphql.GraphQLScalarType({
    name: 'EmailAddress',
    description: 'A field whose value conforms to the standard internet email address format as specified in RFC822: https://www.w3.org/Protocols/rfc822/.',
    serialize: validate$1,
    parseValue: validate$1,
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as email addresses but got a: ${ast.kind}`);
        }
        return validate$1(ast.value);
    },
});

const URL$1 = new graphql.GraphQLScalarType({
    name: 'URL',
    description: 'A field whose value conforms to the standard URL format as specified in RFC3986: https://www.ietf.org/rfc/rfc3986.txt.',
    serialize(value) {
        return new URL(value.toString()).toString();
    },
    parseValue: value => new URL(value.toString()),
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as URLs but got a: ${ast.kind}`);
        }
        return new URL(ast.value.toString());
    },
});

const PHONE_NUMBER_REGEX = /^\+[1-9]\d{1,14}$/;
const PhoneNumber = new graphql.GraphQLScalarType({
    name: 'PhoneNumber',
    description: 'A field whose value conforms to the standard E.164 format as specified in: https://en.wikipedia.org/wiki/E.164. Basically this is +17895551234.',
    serialize(value) {
        if (typeof value !== 'string') {
            throw new TypeError(`Value is not string: ${value}`);
        }
        if (!(PHONE_NUMBER_REGEX.test(value))) {
            throw new TypeError(`Value is not a valid phone number of the form +17895551234 (10-15 digits): ${value}`);
        }
        return value;
    },
    parseValue(value) {
        if (typeof value !== 'string') {
            throw new TypeError(`Value is not string: ${value}`);
        }
        if (!(PHONE_NUMBER_REGEX.test(value))) {
            throw new TypeError(`Value is not a valid phone number of the form +17895551234 (10-15 digits): ${value}`);
        }
        return value;
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as phone numbers but got a: ${ast.kind}`);
        }
        if (!(PHONE_NUMBER_REGEX.test(ast.value))) {
            throw new TypeError(`Value is not a valid phone number of the form +17895551234 (10-15 digits): ${ast.value}`);
        }
        return ast.value;
    },
});

// We're going to start with a limited set as suggested here:
// http://www.pixelenvision.com/1708/zip-postal-code-validation-regex-php-code-for-12-countries/
// and here:
// https://stackoverflow.com/questions/578406/what-is-the-ultimate-postal-code-and-zip-regex
//
// Which gives us the following countries:
//
// US - United States
// UK - United Kingdom
// DE - Germany
// CA - Canada
// FR - France
// IT - Italy
// AU - Australia
// NL - Netherlands
// ES - Spain
// DK - Denmark
// SE - Sweden
// BE - Belgium
// IN - India
// AT - Austria
// PT - Portugal
// CH - Switzerland
// LU - Luxembourg
//
// This is really a practical decision of weight (of the package) vs. completeness.
//
// In the future we might expand this list and use the more comprehensive list found here:
// http://unicode.org/cldr/trac/browser/tags/release-26-0-1/common/supplemental/postalCodeData.xml
// prettier-ignore
const POSTAL_CODE_REGEXES = [
    /* US */ new RegExp(/^\d{5}([-]?\d{4})?$/),
    /* UK */ new RegExp(/^(GIR|[A-Z]\d[A-Z\d]??|[A-Z]{2}\d[A-Z\d]??)[ ]??(\d[A-Z]{2})$/),
    /* DE */ new RegExp(/\b((?:0[1-46-9]\d{3})|(?:[1-357-9]\d{4})|(?:[4][0-24-9]\d{3})|(?:[6][013-9]\d{3}))\b/),
    /* CA */ new RegExp(/^([ABCEGHJKLMNPRSTVXY]\d[ABCEGHJKLMNPRSTVWXYZ]) {0,1}(\d[ABCEGHJKLMNPRSTVWXYZ]\d)$/),
    /* FR */ new RegExp(/^(F-)?((2[A|B])|[0-9]{2})[0-9]{3}$/),
    /* IT */ new RegExp(/^(V-|I-)?[0-9]{5}$/),
    /* AU */ new RegExp(/^(0[289][0-9]{2})|([1345689][0-9]{3})|(2[0-8][0-9]{2})|(290[0-9])|(291[0-4])|(7[0-4][0-9]{2})|(7[8-9][0-9]{2})$/),
    /* NL */ new RegExp(/^[1-9][0-9]{3}\s?([a-zA-Z]{2})?$/),
    /* ES */ new RegExp(/^([1-9]{2}|[0-9][1-9]|[1-9][0-9])[0-9]{3}$/),
    /* DK */ new RegExp(/^([D|d][K|k]( |-))?[1-9]{1}[0-9]{3}$/),
    /* SE */ new RegExp(/^(s-|S-){0,1}[0-9]{3}\s?[0-9]{2}$/),
    /* BE */ new RegExp(/^[1-9]{1}[0-9]{3}$/),
    /* IN */ new RegExp(/^\d{6}$/),
    /* AT */ new RegExp(/^\d{4}$/),
    /* PT */ new RegExp(/^\d{4}([\-]\d{3})?$/),
    /* CH */ new RegExp(/^\d{4}$/),
    /* LU */ new RegExp(/^\d{4}$/),
];
function _testPostalCode(postalCode) {
    let result = false;
    // eslint-disable-next-line no-plusplus
    for (let i = 0; i < POSTAL_CODE_REGEXES.length; i++) {
        const regex = POSTAL_CODE_REGEXES[i];
        if (regex.test(postalCode)) {
            result = true;
            break;
        }
    }
    return result;
}
const PostalCode = new graphql.GraphQLScalarType({
    name: 'PostalCode',
    description: 'A field whose value conforms to the standard postal code formats for United States, United Kingdom, Germany, Canada, France, Italy, Australia, Netherlands, Spain, Denmark, Sweden, Belgium, India, Austria, Portugal, Switzerland or Luxembourg.',
    serialize(value) {
        if (typeof value !== 'string') {
            throw new TypeError(`Value is not string: ${value}`);
        }
        if (!_testPostalCode(value)) {
            throw new TypeError(`Value is not a valid postal code: ${value}`);
        }
        return value;
    },
    parseValue(value) {
        if (typeof value !== 'string') {
            throw new TypeError(`Value is not string: ${value}`);
        }
        if (!_testPostalCode(value)) {
            throw new TypeError(`Value is not a valid postal code: ${value}`);
        }
        return value;
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as postal codes but got a: ${ast.kind}`);
        }
        if (!_testPostalCode(ast.value)) {
            throw new TypeError(`Value is not a valid postal code: ${ast.value}`);
        }
        return ast.value;
    },
});

// Based on https://github.com/stems/graphql-bigint/
function BigIntFactory (name = 'BigInt') {
    BigInt.prototype.toJSON =
        BigInt.prototype.toJSON ||
            function () {
                return this.toString();
            };
    return new graphql.GraphQLScalarType({
        name,
        description: 'The `BigInt` scalar type represents non-fractional signed whole numeric values.',
        serialize: BigInt,
        parseValue: BigInt,
        parseLiteral(ast) {
            if (ast.kind === graphql.Kind.INT ||
                ast.kind === graphql.Kind.FLOAT ||
                ast.kind === graphql.Kind.STRING) {
                return BigInt(ast.value);
            }
            return null;
        },
    });
}

const validate$2 = (value) => {
    const GUID_REGEX = /^(\{){0,1}[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}(\}){0,1}$/gi;
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    if (value.startsWith('{')) {
        value = value.substring(1, value.length - 1);
    }
    if (!GUID_REGEX.test(value)) {
        throw new TypeError(`Value is not a valid GUID: ${value}`);
    }
    return value;
};
const GUID = new graphql.GraphQLScalarType({
    name: `GUID`,
    description: `A field whose value is a generic Globally Unique Identifier: https://en.wikipedia.org/wiki/Universally_unique_identifier.`,
    serialize(value) {
        return validate$2(value);
    },
    parseValue(value) {
        return validate$2(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as GUIDs but got a: ${ast.kind}`);
        }
        return validate$2(ast.value);
    },
});

const validate$3 = (value) => {
    const HEXADECIMAL_REGEX = /^[a-f0-9]+$/i;
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    if (!HEXADECIMAL_REGEX.test(value)) {
        throw new TypeError(`Value is not a valid hexadecimal value: ${value}`);
    }
    return value;
};
const Hexadecimal = new graphql.GraphQLScalarType({
    name: `Hexadecimal`,
    description: `A field whose value is a hexadecimal: https://en.wikipedia.org/wiki/Hexadecimal.`,
    serialize(value) {
        return validate$3(value);
    },
    parseValue(value) {
        return validate$3(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as a hexadecimal but got a: ${ast.kind}`);
        }
        return validate$3(ast.value);
    },
});

const HEX_COLOR_CODE = /^#([A-Fa-f0-9]{6}|[A-Fa-f0-9]{3}|[A-Fa-f0-9]{8})$/;
const validate$4 = (value) => {
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    if (!(HEX_COLOR_CODE.test(value))) {
        throw new TypeError(`Value is not a valid HexColorCode: ${value}`);
    }
    return value;
};
const HexColorCode = new graphql.GraphQLScalarType({
    name: `HexColorCode`,
    description: `A field whose value is a hex color code: https://en.wikipedia.org/wiki/Web_colors.`,
    serialize(value) {
        return validate$4(value);
    },
    parseValue(value) {
        return validate$4(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as hex color codes but got a: ${ast.kind}`);
        }
        return validate$4(ast.value);
    }
});

const validate$5 = (value) => {
    const HSL_REGEX = /^hsl\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*\)$/;
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    if (!HSL_REGEX.test(value)) {
        throw new TypeError(`Value is not a valid HSL color: ${value}`);
    }
    return value;
};
const HSL = new graphql.GraphQLScalarType({
    name: `HSL`,
    description: `A field whose value is a CSS HSL color: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#hsl()_and_hsla().`,
    serialize(value) {
        return validate$5(value);
    },
    parseValue(value) {
        return validate$5(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as HSL colors but got a: ${ast.kind}`);
        }
        return validate$5(ast.value);
    },
});

const HSLA_REGEX = /^hsla\(\s*(-?\d+|-?\d*.\d+)\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)%\s*,\s*(-?\d+|-?\d*.\d+)\s*\)$/;
const validate$6 = (value) => {
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    if (!(HSLA_REGEX.test(value))) {
        throw new TypeError(`Value is not a valid HSLA color: ${value}`);
    }
    return value;
};
const HSLA = new graphql.GraphQLScalarType({
    name: `HSLA`,
    description: `A field whose value is a CSS HSLA color: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#hsl()_and_hsla().`,
    serialize(value) {
        return validate$6(value);
    },
    parseValue(value) {
        return validate$6(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as HSLA colors but got a: ${ast.kind}`);
        }
        return validate$6(ast.value);
    }
});

const IPV4_REGEX = /^(?:(?:(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])(?:\/(?:[0-9]|[1-2][0-9]|3[0-2]))?)$/;
const validate$7 = (value) => {
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    if (!(IPV4_REGEX.test(value))) {
        throw new TypeError(`Value is not a valid IPv4 address: ${value}`);
    }
    return value;
};
const IPv4 = new graphql.GraphQLScalarType({
    name: `IPv4`,
    description: `A field whose value is a IPv4 address: https://en.wikipedia.org/wiki/IPv4.`,
    serialize(value) {
        return validate$7(value);
    },
    parseValue(value) {
        return validate$7(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as IPv4 addresses but got a: ${ast.kind}`);
        }
        return validate$7(ast.value);
    }
});

const IPV6_REGEX = /^(?:(?:(?:[0-9A-Fa-f]{1,4}:){6}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))|::(?:[0-9A-Fa-f]{1,4}:){5}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))|(?:[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:){4}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){0,1}[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:){3}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:){2}(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}:(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})?::(?:[0-9A-Fa-f]{1,4}:[0-9A-Fa-f]{1,4}|(?:(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5])\.){3}(?:0?0?[0-9]|0?[1-9][0-9]|1[0-9][0-9]|2[0-4][0-9]|25[0-5]))|(?:(?:[0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})?::[0-9A-Fa-f]{1,4}|(?:(?:[0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})?::)(?:\/(?:0?0?[0-9]|0?[1-9][0-9]|1[01][0-9]|12[0-8]))?)$/;
const validate$8 = (value) => {
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    if (!(IPV6_REGEX.test(value))) {
        throw new TypeError(`Value is not a valid IPv6 address: ${value}`);
    }
    return value;
};
const IPv6 = new graphql.GraphQLScalarType({
    name: `IPv6`,
    description: `A field whose value is a IPv6 address: https://en.wikipedia.org/wiki/IPv6.`,
    serialize(value) {
        return validate$8(value);
    },
    parseValue(value) {
        return validate$8(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as IPv6 addresses but got a: ${ast.kind}`);
        }
        return validate$8(ast.value);
    }
});

const ISBN_REGEX_ARR = [
    /^(?:ISBN(?:-10)?:? *)?((?=\d{1,5}([ -]?)\d{1,7}\2?\d{1,6}\2?\d)(?:\d\2*){9}[\dX])$/i,
    /^(?:ISBN(?:-13)?:? *)?(97(?:8|9)([ -]?)(?=\d{1,5}\2?\d{1,7}\2?\d{1,6}\2?\d)(?:\d\2*){9}\d)$/i
];
const validate$9 = (value) => {
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    let valid = false;
    for (const regex of ISBN_REGEX_ARR) {
        if (regex.test(value)) {
            valid = true;
            break;
        }
    }
    if (!valid) {
        throw new TypeError(`Value is not a valid ISBN number: ${value}`);
    }
    return value;
};
const ISBN = new graphql.GraphQLScalarType({
    name: `ISBN`,
    description: `A field whose value is a ISBN-10 or ISBN-13 number: https://en.wikipedia.org/wiki/International_Standard_Book_Number.`,
    serialize(value) {
        return validate$9(value);
    },
    parseValue(value) {
        return validate$9(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as ISBN numbers but got a: ${ast.kind}`);
        }
        return validate$9(ast.value);
    }
});

const MAC_REGEX = /^(?:[0-9A-Fa-f]{2}([:-]?)[0-9A-Fa-f]{2})(?:(?:\1|\.)(?:[0-9A-Fa-f]{2}([:-]?)[0-9A-Fa-f]{2})){2}$/;
const validate$a = (value) => {
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    if (!(MAC_REGEX.test(value))) {
        throw new TypeError(`Value is not a valid MAC address: ${value}`);
    }
    return value;
};
const MAC = new graphql.GraphQLScalarType({
    name: `MAC`,
    description: `A field whose value is a IEEE 802 48-bit MAC address: https://en.wikipedia.org/wiki/MAC_address.`,
    serialize(value) {
        return validate$a(value);
    },
    parseValue(value) {
        return validate$a(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as MAC addresses but got a: ${ast.kind}`);
        }
        return validate$a(ast.value);
    }
});

const validate$b = (value) => {
    const parsed = typeof value === 'string' ? parseInt(value, 10) : value;
    if (typeof parsed !== 'number' || Number.isNaN(parsed)) {
        throw new TypeError(`Value is not a number: ${value}`);
    }
    if (parsed === Infinity || parsed === -Infinity) {
        throw new TypeError(`Value is not a finite number: ${value}`);
    }
    if (parsed <= 0 || parsed > 65535) {
        throw new TypeError(`Value is not a valid TCP port: ${value}`);
    }
    return parsed;
};
const Port = new graphql.GraphQLScalarType({
    name: `Port`,
    description: `A field whose value is a valid TCP port within the range of 0 to 65535: https://en.wikipedia.org/wiki/Transmission_Control_Protocol#TCP_ports`,
    serialize(value) {
        return validate$b(value);
    },
    parseValue(value) {
        return validate$b(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.INT) {
            throw new graphql.GraphQLError(`Can only validate integers as TCP ports but got a: ${ast.kind}`);
        }
        return validate$b(ast.value);
    }
});

const RGB_REGEX = /^rgb\(\s*(-?\d+|-?\d*\.\d+(?=%))(%?)\s*,\s*(-?\d+|-?\d*\.\d+(?=%))(\2)\s*,\s*(-?\d+|-?\d*\.\d+(?=%))(\2)\s*\)$/;
const validate$c = (value) => {
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    if (!(RGB_REGEX.test(value))) {
        throw new TypeError(`Value is not a valid RGB color: ${value}`);
    }
    return value;
};
const RGB = new graphql.GraphQLScalarType({
    name: `RGB`,
    description: `A field whose value is a CSS RGB color: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba().`,
    serialize(value) {
        return validate$c(value);
    },
    parseValue(value) {
        return validate$c(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as RGB colors but got a: ${ast.kind}`);
        }
        return validate$c(ast.value);
    }
});

const RGBA_REGEX = /^rgba\(\s*(-?\d+|-?\d*\.\d+(?=%))(%?)\s*,\s*(-?\d+|-?\d*\.\d+(?=%))(\2)\s*,\s*(-?\d+|-?\d*\.\d+(?=%))(\2)\s*,\s*(-?\d+|-?\d*.\d+)\s*\)$/;
const validate$d = (value) => {
    if (typeof value !== 'string') {
        throw new TypeError(`Value is not string: ${value}`);
    }
    if (!(RGBA_REGEX.test(value))) {
        throw new TypeError(`Value is not a valid RGBA color: ${value}`);
    }
    return value;
};
const RGBA = new graphql.GraphQLScalarType({
    name: `RGBA`,
    description: `A field whose value is a CSS RGBA color: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba().`,
    serialize(value) {
        return validate$d(value);
    },
    parseValue(value) {
        return validate$d(value);
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as RGBA colors but got a: ${ast.kind}`);
        }
        return validate$d(ast.value);
    }
});

// https://github.com/abhiaiyer91/graphql-currency-scalars
function generateCurrency(value) {
    if (typeof value !== 'number') {
        throw new TypeError(`Currency cannot represent non integer type ${JSON.stringify(value)}`);
    }
    const currencyInCents = parseInt(value.toString(), 10);
    return (currencyInCents / 100).toLocaleString('en-US', { style: 'currency', currency: 'USD' });
}
function generateCents(value) {
    const digits = value.replace('$', '').replace(',', '');
    const number = parseFloat(digits);
    return number * 100;
}
/**
 * An Currency Scalar.
 *
 * Input:
 *    This scalar takes a currency string as input and
 *    formats it to currency in cents.
 *
 * Output:
 *    This scalar serializes currency in cents to
 *    currency strings.
 */
const USCurrency = new graphql.GraphQLScalarType({
    name: 'USCurrency',
    description: 'A currency string, such as $21.25',
    serialize: generateCurrency,
    parseValue(value) {
        if (typeof value !== 'string') {
            throw new TypeError(`Currency cannot represent non string type ${JSON.stringify(value)}`);
        }
        return generateCents(value);
    },
    parseLiteral(ast) {
        if (ast.kind === graphql.Kind.STRING) {
            if (typeof ast.value === 'string') {
                return generateCents(ast.value);
            }
        }
        throw new TypeError(`Currency cannot represent an invalid currency-string ${JSON.stringify(ast)}.`);
    },
});

function identity(value) {
    return value;
}
// eslint-disable-next-line @typescript-eslint/ban-types
function ensureObject(value) {
    if (typeof value !== 'object' || value === null || Array.isArray(value)) {
        throw new TypeError(`JSONObject cannot represent non-object value: ${value}`);
    }
    return value;
}
function parseObject(ast, variables) {
    const value = Object.create(null);
    ast.fields.forEach((field) => {
        // eslint-disable-next-line no-use-before-define
        value[field.name.value] = parseLiteral(field.value, variables);
    });
    return value;
}
function parseLiteral(ast, variables) {
    switch (ast.kind) {
        case graphql.Kind.STRING:
        case graphql.Kind.BOOLEAN:
            return ast.value;
        case graphql.Kind.INT:
        case graphql.Kind.FLOAT:
            return parseFloat(ast.value);
        case graphql.Kind.OBJECT:
            return parseObject(ast, variables);
        case graphql.Kind.LIST:
            return ast.values.map((n) => parseLiteral(n, variables));
        case graphql.Kind.NULL:
            return null;
        case graphql.Kind.VARIABLE: {
            const name = ast.name.value;
            return variables ? variables[name] : undefined;
        }
    }
}
// This named export is intended for users of CommonJS. Users of ES modules
// should instead use the default export.
const JSON$1 = new graphql.GraphQLScalarType({
    name: 'JSON',
    description: 'The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).',
    serialize: identity,
    parseValue: identity,
    parseLiteral,
});
const JSONObject = new graphql.GraphQLScalarType({
    name: 'JSONObject',
    description: 'The `JSONObject` scalar type represents JSON objects as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).',
    serialize: ensureObject,
    parseValue: ensureObject,
    parseLiteral: parseObject,
});

// Based on https://github.com/arhs/iban.js
/* These are IBAN the specifications for all countries using IBAN
The key is the countrycode, the second item is the length of the IBAN,
The third item is the structure of the underlying BBAN (for validation and formatting)
*/
const IBAN_SPECIFICATIONS = {
    AD: {
        length: 24,
        structure: 'F04F04A12',
        example: 'AD1200012030200359100100',
    },
    AE: { length: 23, structure: 'F03F16', example: 'AE070331234567890123456' },
    AL: {
        length: 28,
        structure: 'F08A16',
        example: 'AL47212110090000000235698741',
    },
    AO: { length: 25, structure: 'F21', example: 'AO69123456789012345678901' },
    AT: { length: 20, structure: 'F05F11', example: 'AT611904300234573201' },
    AZ: {
        length: 28,
        structure: 'U04A20',
        example: 'AZ21NABZ00000000137010001944',
    },
    BA: {
        length: 20,
        structure: 'F03F03F08F02',
        example: 'BA391290079401028494',
    },
    BE: { length: 16, structure: 'F03F07F02', example: 'BE68539007547034' },
    BF: { length: 27, structure: 'F23', example: 'BF2312345678901234567890123' },
    BG: {
        length: 22,
        structure: 'U04F04F02A08',
        example: 'BG80BNBG96611020345678',
    },
    BH: { length: 22, structure: 'U04A14', example: 'BH67BMAG00001299123456' },
    BI: { length: 16, structure: 'F12', example: 'BI41123456789012' },
    BJ: { length: 28, structure: 'F24', example: 'BJ39123456789012345678901234' },
    BR: {
        length: 29,
        structure: 'F08F05F10U01A01',
        example: 'BR9700360305000010009795493P1',
    },
    BY: {
        length: 28,
        structure: 'A04F04A16',
        example: 'BY13NBRB3600900000002Z00AB00',
    },
    CH: { length: 21, structure: 'F05A12', example: 'CH9300762011623852957' },
    CI: {
        length: 28,
        structure: 'U02F22',
        example: 'CI70CI1234567890123456789012',
    },
    CM: { length: 27, structure: 'F23', example: 'CM9012345678901234567890123' },
    CR: { length: 22, structure: 'F04F14', example: 'CR72012300000171549015' },
    CV: { length: 25, structure: 'F21', example: 'CV30123456789012345678901' },
    CY: {
        length: 28,
        structure: 'F03F05A16',
        example: 'CY17002001280000001200527600',
    },
    CZ: {
        length: 24,
        structure: 'F04F06F10',
        example: 'CZ6508000000192000145399',
    },
    DE: { length: 22, structure: 'F08F10', example: 'DE89370400440532013000' },
    DK: { length: 18, structure: 'F04F09F01', example: 'DK5000400440116243' },
    DO: {
        length: 28,
        structure: 'U04F20',
        example: 'DO28BAGR00000001212453611324',
    },
    DZ: { length: 24, structure: 'F20', example: 'DZ8612345678901234567890' },
    EE: {
        length: 20,
        structure: 'F02F02F11F01',
        example: 'EE382200221020145685',
    },
    ES: {
        length: 24,
        structure: 'F04F04F01F01F10',
        example: 'ES9121000418450200051332',
    },
    FI: { length: 18, structure: 'F06F07F01', example: 'FI2112345600000785' },
    FO: { length: 18, structure: 'F04F09F01', example: 'FO6264600001631634' },
    FR: {
        length: 27,
        structure: 'F05F05A11F02',
        example: 'FR1420041010050500013M02606',
    },
    GB: { length: 22, structure: 'U04F06F08', example: 'GB29NWBK60161331926819' },
    GE: { length: 22, structure: 'U02F16', example: 'GE29NB0000000101904917' },
    GI: { length: 23, structure: 'U04A15', example: 'GI75NWBK000000007099453' },
    GL: { length: 18, structure: 'F04F09F01', example: 'GL8964710001000206' },
    GR: {
        length: 27,
        structure: 'F03F04A16',
        example: 'GR1601101250000000012300695',
    },
    GT: {
        length: 28,
        structure: 'A04A20',
        example: 'GT82TRAJ01020000001210029690',
    },
    HR: { length: 21, structure: 'F07F10', example: 'HR1210010051863000160' },
    HU: {
        length: 28,
        structure: 'F03F04F01F15F01',
        example: 'HU42117730161111101800000000',
    },
    IE: { length: 22, structure: 'U04F06F08', example: 'IE29AIBK93115212345678' },
    IL: {
        length: 23,
        structure: 'F03F03F13',
        example: 'IL620108000000099999999',
    },
    IS: {
        length: 26,
        structure: 'F04F02F06F10',
        example: 'IS140159260076545510730339',
    },
    IT: {
        length: 27,
        structure: 'U01F05F05A12',
        example: 'IT60X0542811101000000123456',
    },
    IQ: {
        length: 23,
        structure: 'U04F03A12',
        example: 'IQ98NBIQ850123456789012',
    },
    IR: { length: 26, structure: 'F22', example: 'IR861234568790123456789012' },
    JO: {
        length: 30,
        structure: 'A04F22',
        example: 'JO15AAAA1234567890123456789012',
    },
    KW: {
        length: 30,
        structure: 'U04A22',
        example: 'KW81CBKU0000000000001234560101',
    },
    KZ: { length: 20, structure: 'F03A13', example: 'KZ86125KZT5004100100' },
    LB: {
        length: 28,
        structure: 'F04A20',
        example: 'LB62099900000001001901229114',
    },
    LC: {
        length: 32,
        structure: 'U04F24',
        example: 'LC07HEMM000100010012001200013015',
    },
    LI: { length: 21, structure: 'F05A12', example: 'LI21088100002324013AA' },
    LT: { length: 20, structure: 'F05F11', example: 'LT121000011101001000' },
    LU: { length: 20, structure: 'F03A13', example: 'LU280019400644750000' },
    LV: { length: 21, structure: 'U04A13', example: 'LV80BANK0000435195001' },
    MC: {
        length: 27,
        structure: 'F05F05A11F02',
        example: 'MC5811222000010123456789030',
    },
    MD: { length: 24, structure: 'U02A18', example: 'MD24AG000225100013104168' },
    ME: { length: 22, structure: 'F03F13F02', example: 'ME25505000012345678951' },
    MG: { length: 27, structure: 'F23', example: 'MG1812345678901234567890123' },
    MK: { length: 19, structure: 'F03A10F02', example: 'MK07250120000058984' },
    ML: {
        length: 28,
        structure: 'U01F23',
        example: 'ML15A12345678901234567890123',
    },
    MR: {
        length: 27,
        structure: 'F05F05F11F02',
        example: 'MR1300020001010000123456753',
    },
    MT: {
        length: 31,
        structure: 'U04F05A18',
        example: 'MT84MALT011000012345MTLCAST001S',
    },
    MU: {
        length: 30,
        structure: 'U04F02F02F12F03U03',
        example: 'MU17BOMM0101101030300200000MUR',
    },
    MZ: { length: 25, structure: 'F21', example: 'MZ25123456789012345678901' },
    NL: { length: 18, structure: 'U04F10', example: 'NL91ABNA0417164300' },
    NO: { length: 15, structure: 'F04F06F01', example: 'NO9386011117947' },
    PK: { length: 24, structure: 'U04A16', example: 'PK36SCBL0000001123456702' },
    PL: {
        length: 28,
        structure: 'F08F16',
        example: 'PL61109010140000071219812874',
    },
    PS: {
        length: 29,
        structure: 'U04A21',
        example: 'PS92PALS000000000400123456702',
    },
    PT: {
        length: 25,
        structure: 'F04F04F11F02',
        example: 'PT50000201231234567890154',
    },
    QA: {
        length: 29,
        structure: 'U04A21',
        example: 'QA30AAAA123456789012345678901',
    },
    RO: { length: 24, structure: 'U04A16', example: 'RO49AAAA1B31007593840000' },
    RS: { length: 22, structure: 'F03F13F02', example: 'RS35260005601001611379' },
    SA: { length: 24, structure: 'F02A18', example: 'SA0380000000608010167519' },
    SC: {
        length: 31,
        structure: 'U04F04F16U03',
        example: 'SC18SSCB11010000000000001497USD',
    },
    SE: {
        length: 24,
        structure: 'F03F16F01',
        example: 'SE4550000000058398257466',
    },
    SI: { length: 19, structure: 'F05F08F02', example: 'SI56263300012039086' },
    SK: {
        length: 24,
        structure: 'F04F06F10',
        example: 'SK3112000000198742637541',
    },
    SM: {
        length: 27,
        structure: 'U01F05F05A12',
        example: 'SM86U0322509800000000270100',
    },
    SN: {
        length: 28,
        structure: 'U01F23',
        example: 'SN52A12345678901234567890123',
    },
    ST: {
        length: 25,
        structure: 'F08F11F02',
        example: 'ST68000100010051845310112',
    },
    SV: {
        length: 28,
        structure: 'U04F20',
        example: 'SV62CENR00000000000000700025',
    },
    TL: {
        length: 23,
        structure: 'F03F14F02',
        example: 'TL380080012345678910157',
    },
    TN: {
        length: 24,
        structure: 'F02F03F13F02',
        example: 'TN5910006035183598478831',
    },
    TR: {
        length: 26,
        structure: 'F05F01A16',
        example: 'TR330006100519786457841326',
    },
    UA: {
        length: 29,
        structure: 'F25',
        example: 'UA511234567890123456789012345',
    },
    VA: { length: 22, structure: 'F18', example: 'VA59001123000012345678' },
    VG: { length: 24, structure: 'U04F16', example: 'VG96VPVG0000012345678901' },
    XK: { length: 20, structure: 'F04F10F02', example: 'XK051212012345678906' },
};
const A = 'A'.charCodeAt(0);
const Z = 'Z'.charCodeAt(0);
function parseStructure(structure) {
    // split in blocks of 3 chars
    const regex = structure.match(/(.{3})/g).map(function (block) {
        // parse each structure block (1-char + 2-digits)
        let format;
        const pattern = block.slice(0, 1);
        const repeats = parseInt(block.slice(1), 10);
        switch (pattern) {
            case 'A':
                format = '0-9A-Za-z';
                break;
            case 'B':
                format = '0-9A-Z';
                break;
            case 'C':
                format = 'A-Za-z';
                break;
            case 'F':
                format = '0-9';
                break;
            case 'L':
                format = 'a-z';
                break;
            case 'U':
                format = 'A-Z';
                break;
            case 'W':
                format = '0-9a-z';
                break;
        }
        return '([' + format + ']{' + repeats + '})';
    });
    return new RegExp('^' + regex.join('') + '$');
}
/**
 * Prepare an IBAN for mod 97 computation by moving the first 4 chars to the end and transforming the letters to
 * numbers (A = 10, B = 11, ..., Z = 35), as specified in ISO13616.
 *
 */
function iso13616Prepare(iban) {
    iban = iban.toUpperCase();
    iban = iban.substr(4) + iban.substr(0, 4);
    return iban
        .split('')
        .map(function (n) {
        const code = n.charCodeAt(0);
        if (code >= A && code <= Z) {
            // A = 10, B = 11, ... Z = 35
            return code - A + 10;
        }
        else {
            return n;
        }
    })
        .join('');
}
/**
 * Calculates the MOD 97 10 of the passed IBAN as specified in ISO7064.
 *
 * @param iban
 * @returns {number}
 */
function iso7064Mod97_10(iban) {
    let remainder = iban;
    let block;
    while (remainder.length > 2) {
        block = remainder.slice(0, 9);
        remainder = (parseInt(block, 10) % 97) + remainder.slice(block.length);
    }
    return parseInt(remainder, 10) % 97;
}
function _testIBAN(iban, countryCode, structure) {
    return (structure.length === iban.length &&
        countryCode === iban.slice(0, 2) &&
        parseStructure(structure.structure).test(iban.slice(4)) &&
        iso7064Mod97_10(iso13616Prepare(iban)) === 1);
}
function validate$e(iban) {
    iban = iban.toUpperCase();
    const countryCode = iban.slice(0, 2);
    const countryStructure = IBAN_SPECIFICATIONS[countryCode];
    return !!countryStructure && _testIBAN(iban, countryCode, countryStructure);
}
const IBAN = new graphql.GraphQLScalarType({
    name: `IBAN`,
    description: `A field whose value is an International Bank Account Number (IBAN): https://en.wikipedia.org/wiki/International_Bank_Account_Number.`,
    serialize(value) {
        if (typeof value !== 'string') {
            throw new TypeError(`Value is not string: ${value}`);
        }
        if (!validate$e(value)) {
            throw new TypeError(`Value is not a valid IBAN: ${value}`);
        }
        return value;
    },
    parseValue(value) {
        if (typeof value !== 'string') {
            throw new TypeError(`Value is not string: ${value}`);
        }
        if (!validate$e(value)) {
            throw new TypeError(`Value is not a valid IBAN: ${value}`);
        }
        return value;
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as IBANs but got a: ${ast.kind}`);
        }
        if (!validate$e(ast.value)) {
            throw new TypeError(`Value is not a valid IBAN: ${ast.value}`);
        }
        return ast.value;
    },
});

const MONGODB_OBJECTID_REGEX = new RegExp(/^[A-Fa-f0-9]{24}$/);
const ObjectID = new graphql.GraphQLScalarType({
    name: 'ObjectID',
    description: 'A field whose value conforms with the standard mongodb object ID as described here: https://docs.mongodb.com/manual/reference/method/ObjectId/#ObjectId. Example: 5e5677d71bdc2ae76344968c',
    serialize(value) {
        if (!MONGODB_OBJECTID_REGEX.test(value)) {
            throw new TypeError(`Value is not a valid mongodb object id of form: ${value}`);
        }
        return value;
    },
    parseValue(value) {
        if (!MONGODB_OBJECTID_REGEX.test(value)) {
            throw new TypeError(`Value is not a valid mongodb object id of form: ${value}`);
        }
        return value;
    },
    parseLiteral(ast) {
        if (ast.kind !== graphql.Kind.STRING) {
            throw new graphql.GraphQLError(`Can only validate strings as mongodb object id but got a: ${ast.kind}`);
        }
        if (!MONGODB_OBJECTID_REGEX.test(ast.value)) {
            throw new TypeError(`Value is not a valid mongodb object id of form: ${ast.value}`);
        }
        return ast.value;
    },
});

const Void = new graphql.GraphQLScalarType({
    name: 'Void',
    description: 'Represents NULL values',
    serialize() {
        return null;
    },
    parseValue() {
        return null;
    },
    parseLiteral() {
        return null;
    },
});

const BigIntResolver = BigIntFactory('BigInt');
const LongResolver = BigIntFactory('Long');
const NonNegativeIntResolver = NonNegativeIntFactory('NonNegativeInt');
const UnsignedIntResolver = NonNegativeIntFactory('UnsignedInt');
const NonNegativeFloatResolver = NonNegativeFloatFactory('NonNegativeFloat');
const UnsignedFloatResolver = NonNegativeFloatFactory('UnsignedFloat');

const index = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DateTime: DateTime,
  UtcOffset: UtcOffset,
  NonPositiveInt: NonPositiveInt,
  PositiveInt: PositiveInt,
  NonNegativeInt: NonNegativeIntResolver,
  UnsignedInt: UnsignedIntResolver,
  NegativeInt: NegativeInt,
  NonPositiveFloat: NonPositiveFloat,
  PositiveFloat: PositiveFloat,
  NonNegativeFloat: NonNegativeFloatResolver,
  UnsignedFloat: UnsignedFloatResolver,
  NegativeFloat: NegativeFloat,
  EmailAddress: EmailAddress,
  URL: URL$1,
  PhoneNumber: PhoneNumber,
  PostalCode: PostalCode,
  BigInt: BigIntResolver,
  Long: LongResolver,
  GUID: GUID,
  Hexadecimal: Hexadecimal,
  HexColorCode: HexColorCode,
  HSL: HSL,
  HSLA: HSLA,
  IPv4: IPv4,
  IPv6: IPv6,
  ISBN: ISBN,
  MAC: MAC,
  Port: Port,
  RGB: RGB,
  RGBA: RGBA,
  USCurrency: USCurrency,
  JSON: JSON$1,
  JSONObject: JSONObject,
  IBAN: IBAN,
  ObjectID: ObjectID,
  Void: Void
});

const BigIntMock = () => BigInt(Number.MAX_SAFE_INTEGER);
const DateTime$1 = () => new Date();
const UtcOffset$1 = () => '+03:00';
const EmailAddress$1 = () => 'test@test.com';
const NegativeFloat$1 = () => -123.45;
const NegativeInt$1 = () => -123;
const NonNegativeFloat = () => 123.45;
const NonNegativeInt = () => 123;
const NonPositiveFloat$1 = () => -123.45;
const NonPositiveInt$1 = () => -123;
const PhoneNumber$1 = () => '+17895551234';
const ObjectID$1 = () => '5e5677d71bdc2ae76344968c';
const PositiveFloat$1 = () => 123.45;
const PositiveInt$1 = () => 123;
const PostalCode$1 = () => '60031';
const URLMock = () => new URL('http://www.test.com/');
// https://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
const GUID$1 = () => {
    // Public Domain/MIT
    let d = new Date().getTime();
    if (typeof performance !== 'undefined' &&
        typeof performance.now === 'function') {
        d += performance.now(); // use high-precision timer if available
    }
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
        // tslint:disable-next-line: no-bitwise
        const r = (d + Math.random() * 16) % 16 | 0;
        d = Math.floor(d / 16);
        // tslint:disable-next-line: no-bitwise
        return (c === 'x' ? r : (r & 0x3) | 0x8).toString(16);
    });
};
const HexColorCode$1 = () => '#' + Math.floor(Math.random() * 16777215).toString(16);
const Hexadecimal$1 = () => Math.floor(Math.random() * 16777215).toString(16);
const randomVal = (min, max) => {
    return Math.floor(Math.random() * (max - min) + 1) + min;
};
// https://codepen.io/meowwwls/pen/jbEJRp
const HSL$1 = () => `hsl(${randomVal(0, 360)}, ${randomVal(30, 95)}%, ${randomVal(30, 80)}%)`;
const HSLA$1 = () => `hsla(${randomVal(0, 360)}, ${randomVal(30, 95)}%, ${randomVal(30, 80)}%, ${Math.random()})`;
// https://stackoverflow.com/questions/43464519/creating-fake-ip-address-using-javascript
const IPv4$1 = () => Math.floor(Math.random() * 255) +
    1 +
    '.' +
    (Math.floor(Math.random() * 255) + 0) +
    '.' +
    (Math.floor(Math.random() * 255) + 0) +
    '.' +
    (Math.floor(Math.random() * 255) + 0);
const IPv6$1 = () => '2001:0db8:85a3:0000:0000:8a2e:0370:7334';
// http://jsfiddle.net/guest271314/qhbC9/
const MAC$1 = () => 'XX:XX:XX:XX:XX:XX'.replace(/X/g, () => '0123456789ABCDEF'.charAt(Math.floor(Math.random() * 16)));
const Port$1 = () => randomVal(0, 65535);
const RGB$1 = () => `rgb(${randomVal(0, 255)}, ${randomVal(0, 255)}, ${randomVal(0, 255)})`;
const RGBA$1 = () => `rgba(${randomVal(0, 255)}, ${randomVal(0, 255)}, ${randomVal(0, 255)}, ${Math.random()})`;
const ISBN$1 = () => `978-3-16-148410-0`;
const USCurrency$1 = () => 1000;
const JSON$2 = () => ({});
const JSONObject$1 = () => ({});
const IBAN$1 = () => 'NL55INGB4789170233';
const Void$1 = () => null;

const mocks = /*#__PURE__*/Object.freeze({
  __proto__: null,
  DateTime: DateTime$1,
  UtcOffset: UtcOffset$1,
  EmailAddress: EmailAddress$1,
  NegativeFloat: NegativeFloat$1,
  NegativeInt: NegativeInt$1,
  NonNegativeFloat: NonNegativeFloat,
  NonNegativeInt: NonNegativeInt,
  NonPositiveFloat: NonPositiveFloat$1,
  NonPositiveInt: NonPositiveInt$1,
  PhoneNumber: PhoneNumber$1,
  ObjectID: ObjectID$1,
  PositiveFloat: PositiveFloat$1,
  PositiveInt: PositiveInt$1,
  PostalCode: PostalCode$1,
  GUID: GUID$1,
  HexColorCode: HexColorCode$1,
  Hexadecimal: Hexadecimal$1,
  HSL: HSL$1,
  HSLA: HSLA$1,
  IPv4: IPv4$1,
  IPv6: IPv6$1,
  MAC: MAC$1,
  Port: Port$1,
  RGB: RGB$1,
  RGBA: RGBA$1,
  ISBN: ISBN$1,
  USCurrency: USCurrency$1,
  JSON: JSON$2,
  JSONObject: JSONObject$1,
  IBAN: IBAN$1,
  Void: Void$1,
  URL: URLMock,
  UnsignedInt: NonNegativeInt,
  UnsignedFloat: NonNegativeFloat,
  Long: BigIntMock,
  BigInt: BigIntMock
});

const BigInt$1 = 'scalar BigInt';
const DateTime$2 = 'scalar DateTime';
const UtcOffset$2 = 'scalar UtcOffset';
const EmailAddress$2 = 'scalar EmailAddress';
const GUID$2 = `scalar GUID`;
const Hexadecimal$2 = `scalar Hexadecimal`;
const HexColorCode$2 = `scalar HexColorCode`;
const HSL$2 = `scalar HSL`;
const HSLA$2 = `scalar HSLA`;
const IBAN$2 = `scalar IBAN`;
const IPv4$2 = `scalar IPv4`;
const IPv6$2 = `scalar IPv6`;
const ISBN$2 = `scalar ISBN`;
const JSON$3 = `scalar JSON`;
const JSONObject$2 = `scalar JSONObject`;
const MAC$2 = `scalar MAC`;
const NegativeFloat$2 = 'scalar NegativeFloat';
const NegativeInt$2 = 'scalar NegativeInt';
const NonNegativeFloat$1 = 'scalar NonNegativeFloat';
const NonNegativeInt$1 = 'scalar NonNegativeInt';
const NonPositiveFloat$2 = 'scalar NonPositiveFloat';
const NonPositiveInt$2 = 'scalar NonPositiveInt';
const PhoneNumber$2 = 'scalar PhoneNumber';
const Port$2 = `scalar Port`;
const PositiveFloat$2 = 'scalar PositiveFloat';
const PositiveInt$2 = 'scalar PositiveInt';
const PostalCode$2 = 'scalar PostalCode';
const RGB$2 = `scalar RGB`;
const RGBA$2 = `scalar RGBA`;
const URL$2 = 'scalar URL';
const USCurrency$2 = `scalar USCurrency`;
const UnsignedFloat = 'scalar UnsignedFloat';
const UnsignedInt = 'scalar UnsignedInt';
const Long = 'scalar Long';
const ObjectID$2 = 'scalar ObjectID';
const Void$2 = 'scalar Void';
const typeDefs = [
    DateTime$2,
    UtcOffset$2,
    EmailAddress$2,
    NegativeFloat$2,
    NegativeInt$2,
    NonNegativeFloat$1,
    NonNegativeInt$1,
    NonPositiveFloat$2,
    NonPositiveInt$2,
    PhoneNumber$2,
    PositiveFloat$2,
    PositiveInt$2,
    PostalCode$2,
    UnsignedFloat,
    UnsignedInt,
    URL$2,
    BigInt$1,
    Long,
    GUID$2,
    Hexadecimal$2,
    HexColorCode$2,
    HSL$2,
    HSLA$2,
    IPv4$2,
    IPv6$2,
    ISBN$2,
    MAC$2,
    Port$2,
    RGB$2,
    RGBA$2,
    USCurrency$2,
    JSON$3,
    JSONObject$2,
    IBAN$2,
    ObjectID$2,
    Void$2,
];

class RegularExpression extends graphql.GraphQLScalarType {
    constructor(name, regex, options = {}) {
        const REGEX = new RegExp(regex);
        const errorMessage = options.errorMessage
            ? options.errorMessage
            : (r, v) => `Value does not match the regular expression ${r}: ${v}`;
        super({
            name,
            description: `A field whose value matches the provided regular expression ${regex}.`,
            serialize(value) {
                if (typeof value !== 'string') {
                    throw new TypeError(`Value is not string: ${value}`);
                }
                if (!REGEX.test(value)) {
                    throw new TypeError(errorMessage(regex, value));
                }
                return value;
            },
            parseValue(value) {
                if (typeof value !== 'string') {
                    throw new TypeError(`Value is not string: ${value}`);
                }
                if (!REGEX.test(value)) {
                    throw new TypeError(errorMessage(regex, value));
                }
                return value;
            },
            parseLiteral(ast) {
                if (ast.kind !== graphql.Kind.STRING) {
                    throw new graphql.GraphQLError(`Can only validate strings as regular expressions but got a: ${ast.kind}`);
                }
                if (!REGEX.test(ast.value)) {
                    throw new TypeError(errorMessage(regex, ast.value));
                }
                return ast.value;
            },
        });
    }
}

exports.BigIntMock = BigIntMock;
exports.BigIntResolver = BigIntResolver;
exports.BigIntTypeDefinition = BigInt$1;
exports.DateTimeMock = DateTime$1;
exports.DateTimeResolver = DateTime;
exports.DateTimeTypeDefinition = DateTime$2;
exports.EmailAddressMock = EmailAddress$1;
exports.EmailAddressResolver = EmailAddress;
exports.EmailAddressTypeDefinition = EmailAddress$2;
exports.GUIDDefinition = GUID$2;
exports.GUIDMock = GUID$1;
exports.GUIDResolver = GUID;
exports.GraphQLBigInt = BigIntResolver;
exports.GraphQLDateTime = DateTime;
exports.GraphQLEmailAddress = EmailAddress;
exports.GraphQLGUID = GUID;
exports.GraphQLHSL = HSL;
exports.GraphQLHSLA = HSLA;
exports.GraphQLHexColorCode = HexColorCode;
exports.GraphQLHexadecimal = Hexadecimal;
exports.GraphQLIBAN = IBAN;
exports.GraphQLIPv4 = IPv4;
exports.GraphQLIPv6 = IPv6;
exports.GraphQLISBN = ISBN;
exports.GraphQLJSON = JSON$1;
exports.GraphQLJSONObject = JSONObject;
exports.GraphQLLong = LongResolver;
exports.GraphQLMAC = MAC;
exports.GraphQLNegativeFloat = NegativeFloat;
exports.GraphQLNegativeInt = NegativeInt;
exports.GraphQLNonNegativeFloat = NonNegativeFloatResolver;
exports.GraphQLNonNegativeInt = NonNegativeIntResolver;
exports.GraphQLNonPositiveFloat = NonPositiveFloat;
exports.GraphQLNonPositiveInt = NonPositiveInt;
exports.GraphQLObjectID = ObjectID;
exports.GraphQLPhoneNumber = PhoneNumber;
exports.GraphQLPort = Port;
exports.GraphQLPositiveFloat = PositiveFloat;
exports.GraphQLPositiveInt = PositiveInt;
exports.GraphQLPostalCode = PostalCode;
exports.GraphQLRGB = RGB;
exports.GraphQLRGBA = RGBA;
exports.GraphQLURL = URL$1;
exports.GraphQLUSCurrency = USCurrency;
exports.GraphQLUnsignedFloat = UnsignedFloatResolver;
exports.GraphQLUnsignedInt = UnsignedIntResolver;
exports.GraphQLUtcOffset = UtcOffset;
exports.GraphQLVoid = Void;
exports.HSLADefinition = HSLA$2;
exports.HSLAMock = HSLA$1;
exports.HSLAResolver = HSLA;
exports.HSLDefinition = HSL$2;
exports.HSLMock = HSL$1;
exports.HSLResolver = HSL;
exports.HexColorCodeDefinition = HexColorCode$2;
exports.HexColorCodeMock = HexColorCode$1;
exports.HexColorCodeResolver = HexColorCode;
exports.HexadecimalMock = Hexadecimal$1;
exports.HexadecimalResolver = Hexadecimal;
exports.HexadecimalTypeDefinition = Hexadecimal$2;
exports.IBANMock = IBAN$1;
exports.IBANResolver = IBAN;
exports.IBANTypeDefinition = IBAN$2;
exports.IPv4Definition = IPv4$2;
exports.IPv4Mock = IPv4$1;
exports.IPv4Resolver = IPv4;
exports.IPv6Definition = IPv6$2;
exports.IPv6Mock = IPv6$1;
exports.IPv6Resolver = IPv6;
exports.ISBNDefinition = ISBN$2;
exports.ISBNMock = ISBN$1;
exports.ISBNResolver = ISBN;
exports.JSONDefinition = JSON$3;
exports.JSONMock = JSON$2;
exports.JSONObjectDefinition = JSONObject$2;
exports.JSONObjectMock = JSONObject$1;
exports.JSONObjectResolver = JSONObject;
exports.JSONResolver = JSON$1;
exports.LongMock = BigIntMock;
exports.LongResolver = LongResolver;
exports.LongTypeDefinition = Long;
exports.MACDefinition = MAC$2;
exports.MACMock = MAC$1;
exports.MACResolver = MAC;
exports.NegativeFloatMock = NegativeFloat$1;
exports.NegativeFloatResolver = NegativeFloat;
exports.NegativeFloatTypeDefinition = NegativeFloat$2;
exports.NegativeIntMock = NegativeInt$1;
exports.NegativeIntResolver = NegativeInt;
exports.NegativeIntTypeDefinition = NegativeInt$2;
exports.NonNegativeFloatMock = NonNegativeFloat;
exports.NonNegativeFloatResolver = NonNegativeFloatResolver;
exports.NonNegativeFloatTypeDefinition = NonNegativeFloat$1;
exports.NonNegativeIntMock = NonNegativeInt;
exports.NonNegativeIntResolver = NonNegativeIntResolver;
exports.NonNegativeIntTypeDefinition = NonNegativeInt$1;
exports.NonPositiveFloatMock = NonPositiveFloat$1;
exports.NonPositiveFloatResolver = NonPositiveFloat;
exports.NonPositiveFloatTypeDefinition = NonPositiveFloat$2;
exports.NonPositiveIntMock = NonPositiveInt$1;
exports.NonPositiveIntResolver = NonPositiveInt;
exports.NonPositiveIntTypeDefinition = NonPositiveInt$2;
exports.ObjectIDMock = ObjectID$1;
exports.ObjectIDResolver = ObjectID;
exports.ObjectIDTypeDefinition = ObjectID$2;
exports.PhoneNumberMock = PhoneNumber$1;
exports.PhoneNumberResolver = PhoneNumber;
exports.PhoneNumberTypeDefinition = PhoneNumber$2;
exports.PortDefinition = Port$2;
exports.PortMock = Port$1;
exports.PortResolver = Port;
exports.PositiveFloatMock = PositiveFloat$1;
exports.PositiveFloatResolver = PositiveFloat;
exports.PositiveFloatTypeDefinition = PositiveFloat$2;
exports.PositiveIntMock = PositiveInt$1;
exports.PositiveIntResolver = PositiveInt;
exports.PositiveIntTypeDefinition = PositiveInt$2;
exports.PostalCodeMock = PostalCode$1;
exports.PostalCodeResolver = PostalCode;
exports.PostalCodeTypeDefinition = PostalCode$2;
exports.RGBADefinition = RGBA$2;
exports.RGBAMock = RGBA$1;
exports.RGBAResolver = RGBA;
exports.RGBDefinition = RGB$2;
exports.RGBMock = RGB$1;
exports.RGBResolver = RGB;
exports.RegularExpression = RegularExpression;
exports.URLMock = URLMock;
exports.URLResolver = URL$1;
exports.URLTypeDefinition = URL$2;
exports.USCurrencyDefinition = USCurrency$2;
exports.USCurrencyMock = USCurrency$1;
exports.USCurrencyResolver = USCurrency;
exports.UnsignedFloatMock = NonNegativeFloat;
exports.UnsignedFloatResolver = UnsignedFloatResolver;
exports.UnsignedFloatTypeDefinition = UnsignedFloat;
exports.UnsignedIntMock = NonNegativeInt;
exports.UnsignedIntResolver = UnsignedIntResolver;
exports.UnsignedIntTypeDefinition = UnsignedInt;
exports.UtcOffsetMock = UtcOffset$1;
exports.UtcOffsetResolver = UtcOffset;
exports.UtcOffsetTypeDefinition = UtcOffset$2;
exports.VoidMock = Void$1;
exports.VoidResolver = Void;
exports.VoidTypeDefinition = Void$2;
exports.mocks = mocks;
exports.resolvers = index;
exports.typeDefs = typeDefs;
//# sourceMappingURL=index.cjs.js.map
